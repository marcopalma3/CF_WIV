---
title: "Factors associated with within-individual variability of lung function for people with cystic fibrosis: a longitudinal registry study"
author: "Marco Palma"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    #code_folding: hide
    keep_md: no
    number_sections: no
    theme: readable
    toc: no
    toc_depth: 3
    toc_float:
      collapsed: yes
  html_notebook:
    code_folding: hide
    highlight: tango
    theme: readable
  pdf_document:
    toc: no
    toc_depth: '3'
  word_document:
    toc: no
    toc_depth: '3'
---

This is the code for the paper "Factors associated with within-individual variability of lung function for people with cystic fibrosis: a longitudinal registry study" by Palma et al., in submission.

```{css, echo=FALSE}
    body .main-container {
      max-width: 100% !important;
      width: 100% !important;
    }
    body {
      max-width: 1500px !important;
    }
```

```{r setup, include=FALSE}

.libPaths("H:/Documents/R/win-library/4.1")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, 
                      message = FALSE, tidy = TRUE 
                      , fig.show="hold", out.width = "50%"
                      , dev = c('png', "cairo_pdf") , fig.path="figures_Epinet/", fig.dim = c(5, 5)
                      )

```

```{r packages}
library(pacman)

p_load(dplyr, tidyr, ggplot2, lubridate, knitr, kableExtra, stringr, 
       ggpubr, ggridges) #, devtools
p_load(pipeR, DiagrammeR,  DiagrammeRsvg, magrittr, rsvg)
p_load(brms, brmsmargins, posterior, bayesplot, tidybayes, survival, emmeans)

theme_set(theme_light(base_size = 14) + 
            theme(panel.grid.minor = element_blank(),
                  plot.margin = margin(t = 6, r = 6, b = 6, l = 6, 
                                       unit = "pt"),
                  legend.position = "bottom",
                  legend.margin=margin(0,0,0,0,unit = "pt"),
                  legend.box.margin=margin(0,0,0,0,unit = "pt"))
)


'%ni%' <- Negate('%in%')

var_long <- "gli_fev"  
```

## Introduction

### Dataset

Import the dataset and store it in the `cfdata` object.

```{r importdata, cache = TRUE, echo = FALSE}
cfdata <- read.csv("Q:/cysticfibrosis/data/CFT_EpiNet2020_master_v3_5July2022.csv")


```

```{r datawrangling, echo = TRUE, eval = TRUE}
cfdata_clean <- cfdata %>% 
  mutate(s01encounterdate = lubridate::dmy(s01encounterdate),
         dmg_dateofdeath = lubridate::dmy(dmg_dateofdeath),
         dmg_dateofbirth = lubridate::dmy(dmg_dateofbirth)) %>%
  mutate_at(c("patient_id", "sitecode_anon", "dmg_sex",
              "dmg_ethnicity_gli", "s01isthisanannualreviewencounter",
              "s05culturespeciesstaph", "s05culturespeciespseudoaeruginos",
              "s07pancreaticenzymesupplements"),
            list(~factor(.)))

rm(cfdata)
```

The number of rows is `r nrow(cfdata_clean)` and the number of variables is `r ncol(cfdata_clean)`. The number of unique patient ID is `r length(unique(cfdata_clean$patient_id))`.



### Subset used for the analysis - inclusion criteria

We have kept only the first visit per year per each patient. To account for all transplants, you need to first compute transplanted indicators, then remove missing values (often, in the year of transplant `gli_fev` is missing).

```{r cfdata_included}
explanatory_before <- c("patient_id", "age", "dmg_sex", "dmg_ageatdiagnosis", "dmg_dateofbirth", "f508_class")



cf2 <- cfdata_clean %>>%
  (~ c(nrow(.), length(unique(.$patient_id))) -> a1) %>>%
  filter(age >= 18 & age <= 50) %>>%
  (~ c(nrow(.), length(unique(.$patient_id))) -> a2) %>>%
  group_by(patient_id) %>% filter(year != lag(year) | row_number() == 1) %>>%
  (~ c(nrow(.), length(unique(.$patient_id))) -> a3) %>>%
  group_by(patient_id) %>% 
  mutate(Transplanted = cumsum(s10transplantsincelastannualrevi == "Y")) %>% 
  filter(Transplanted == 0) %>>%  
  (~ c(nrow(.), length(unique(.$patient_id))) -> a4)


cf2_bypatient <- cf2 %>% 
  select(patient_id, dmg_dateofbirth, dmg_sex, dmg_ageatdiagnosis, f508_class) %>% 
  distinct(across(everything())) %>%
  drop_na() %>% ##add_count(patient_id, name = "no_records") 
  mutate("diagnosedafter1yo" = factor(ifelse(dmg_ageatdiagnosis>1, 1, 0)),
         "f508_homozygous" = factor(ifelse(f508_class == "Homoz", 1, 0)),
         "yob" = year(dmg_dateofbirth))


cf2 <- left_join(cf2, 
                 select(cf2_bypatient, patient_id, diagnosedafter1yo, f508_homozygous, yob),
                 by = "patient_id")




explanatory_after <- c("patient_id", "age", "dmg_sex", "diagnosedafter1yo", "dmg_dateofbirth", "f508_homozygous")
dependent <-  var_long

cf2%>%
  finalfit::missing_pattern(dependent, explanatory_before, rotate.names = TRUE)


cf2 <- cf2 %>%
  filter(!!sym(var_long) > 0)  %>%
  drop_na(all_of(explanatory_after)) %>>%
  (~ c(nrow(.), length(unique(.$patient_id))) -> a5) 


```



```{r CF_inclusion_criteria, echo = TRUE, eval = TRUE}
inclusion_diagram  <- DiagrammeR::grViz("digraph {
  graph [layout = dot, rankdir = TB]

  node [shape = rectangle, fixedsize=true, width=4]
  rec1 [label = 'Original dataset\\n(N = @@6, n = @@1)']
  rec2 [label = 'Adults (18-49 years old)\\n(N = @@7, n = @@2)']
  rec3 [label = 'First review every year\\n(N = @@8, n = @@3)']
  rec4 [label = 'Annual reviews before lung transplant\\n(N = @@9, n = @@4)']
  rec5 [label = 'Non missing values of FEV\u2081 and covariates\\n(N = @@10, n = @@5)']

  # edge definitions with the node IDs
  rec1 -> rec2 -> rec3 -> rec4 -> rec5   
  }

  [1]: a1
  [2]: a2
  [3]: a3
  [4]: a4
  [5]: a5
  [6]: a1[2]
  [7]: a2[2]
  [8]: a3[2]
  [9]: a4[2]
  [10]: a5[2]
  ")


inclusion_diagram

inclusion_diagram %>>%   print(.) %>>%
  export_svg %>%
  charToRaw %>%
  rsvg_pdf("CFAdult_inclusiondiagram.pdf", width = 350)
```


### Plots after inclusion criteria


```{r outcome_spaghetti_afterinclusion}

p1 <- cf2[1:3971,] %>%    #3971  
  drop_na(age, all_of(var_long)) %>%
  ggplot(data = ., 
         aes_string(x = "age", y = var_long,  group = "patient_id"  #,color = "grey1"
         )
  ) + 
  geom_point(alpha = 0.05) + 
  geom_line(alpha = 0.05) +
  geom_smooth(data = cf2, 
              aes(x = age, y = get(var_long), group = dmg_sex, color = dmg_sex, fill = dmg_sex, linetype = dmg_sex),
              size = 1.25) +
  theme(legend.position = "bottom" ,
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        plot.margin = margin(t = 6, r = 6, b = 0, l = 6, 
                             unit = "pt") 
  ) + 
  scale_x_continuous(limits = c(18,50), 
                     breaks = scales::pretty_breaks(n = 10), 
                     expand = expansion(add = 0)) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(add = 0.01)) + 
  scale_color_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) + 
  scale_fill_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) + 
  scale_linetype_manual(breaks = c("F", "M"), values = c("81", "11"), 
                        na.value = "solid") +
  labs(x = "Age",
       y = bquote(FEV[1]),
       color = "Sex",
       fill = "Sex",
       linetype = "Sex"
) 


p2 <- ggplot(cf2) +
  geom_density(aes(age, after_stat(count), fill = dmg_sex), 
               position = "fill", alpha = 0.5, adjust = 1/2) + 
  stat_ecdf(aes(age, color = dmg_sex, linetype = dmg_sex), 
            geom = "step", pad = FALSE, lwd = 1.25) + 
  geom_hline(aes(yintercept = 0.5), lty = 2) +  
  labs(x = "Age", 
       y = "Sex distribution", 
       fill = "Sex", linetype = "Sex") +
  scale_x_continuous(limits = c(18,50), 
                     breaks = scales::pretty_breaks(n = 10), 
                     expand = expansion(add = 0)) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 5), 
                     labels = scales::percent, 
                     expand = expansion(add = 0)) +
  scale_color_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) + 
  scale_fill_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) +
  scale_linetype_manual(breaks = c("F", "M"), values = c("81", "11"),
                        na.value = "solid") +
  theme(legend.position="none", 
        plot.margin = margin(t = 0, r = 6, b = 6, l = 6, 
                             unit = "pt")
  )

ggpubr::ggarrange(p1, NULL, p2, 
                  heights = c(1.2, 0.05, 1),
                  ncol = 1, nrow = 3, align = "v", 
                  common.legend = TRUE, legend = "bottom")

rm(p1,p2)

```

```{r encounterspersub_afterinclusion, fig.dim=c(5,2.5)}
cf2 %>% 
  group_by(patient_id) %>%
  summarise("no_encounters" = n()) %>% 
  ggplot(., aes(x=no_encounters)) + 
  geom_bar(width = 0.5) + 
  scale_x_continuous(limits = c(0,NA), 
                     breaks =scales::pretty_breaks(n = 8),  
                     expand = expansion(add = 0)) +
  scale_y_continuous(limits = c(0,NA), 
                     breaks = seq(0,2000,by =100),  
                     expand = expansion(add = 10)) +
  labs(x = "Annual reviews",
       y = "Number of individuals"
  ) 
```

```{r fevbysex, echo = FALSE, eval = FALSE}
#names(cfdata_clean)[grep("fev", names(cfdata_clean))]

#cf2 %>% 
#    select(patient_id, gli_percpredfev, year) %>%
#    filter(!is.na(gli_percpredfev)) %>% summarise(year) %>% table()

ggplot(cf2, aes(x=age, fill=dmg_sex)) +   
  geom_histogram(aes(y = after_stat(count / sum(count))), 
                 binwidth = 2, alpha=0.2, position = 'identity') + 
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = "Age", y = "Frequency", fill = "Sex") +
  theme(legend.position = "bottom")

# cf2 %>% 
#   select(patient_id, dmg_sex, dmg_deathhaspatientdied) %>% 
#   unique() %>% 
#   count(dmg_deathhaspatientdied, dmg_sex) %>%
#   group_by(dmg_deathhaspatientdied) %>%
#   mutate(prop = prop.table(n))

cf2 %>% 
  add_count(patient_id, name = "no_visits") %>%   
  distinct(patient_id, no_visits, dmg_sex) %>%
  ggplot(., aes(x=no_visits, color = dmg_sex)) + 
  stat_ecdf() + 
  scale_x_continuous(limits = c(0,NA), 
                     breaks =scales::pretty_breaks(n = 8),  
                     expand = expansion(add = 0)) +
  labs(x = "Visits",
       y = "Proportion of individuals"#,title = "Number of visits per subject"
  ) 

# cfdata_clean %>%
#     group_by(patient_id) %>%
#     arrange(age) %>%
#     filter(row_number()==1) %>% 
#   ggplot(., aes(x=age)) + 
#   geom_boxplot() + 
#   scale_x_continuous(breaks = scales::pretty_breaks(n = 10))

# cfdata_clean %>% 
#     select(patient_id, gli_predfevfvc, year) %>%
#     filter(!is.na(gli_predfevfvc)) %>% summarise(year) %>% table()
```

### Table 1 

```{r table1, echo = TRUE, eval = TRUE}
tab1_prep <- cf2 %>%
    group_by(patient_id) %>%
    summarise(dmg_sex, 
              "no_encounters" = n(), 
              "ageatdiagnosis" = first(dmg_ageatdiagnosis),
              "diagnosedafter1yo" = first(diagnosedafter1yo),
              "f508_homozygous" = first(f508_homozygous),
              "ageatfirstvisit" = first(age),
              "ageatlastvisit" = last(age),
              "death_status" = !is.na(dmg_dateofdeath), 
              "yearofbirth" = first(yob),
              "first_fev" = first(!!sym(var_long)),
              "last_fev" = last(!!sym(var_long))) %>%
  distinct(across(everything())) 

quantile_interval <- function(x){
  qts <- round(quantile(x, probs = c(0.25,0.5,0.75), na.rm = T), 2)
  paste0(qts[2], " (", qts[1], "; ", qts[3], ")" )
}





tab1_tot <- tab1_prep %>% mutate(dmg_sex = "Total") %>%
    group_by(dmg_sex) %>%
    summarise("Number of individuals" = n_distinct(patient_id),
              "Median number of encounters per individual (IQR)" = quantile_interval(no_encounters),
              "Difference in years between first and last encounter date (IQR)" = quantile_interval(ageatlastvisit - ageatfirstvisit),
              "Median age at diagnosis in years (IQR)" = quantile_interval(ageatdiagnosis),
              "No of individuals diagnosed within the first year after birth (%)" = paste0(sum(diagnosedafter1yo == 0, na.rm = T),
                                                                                        " (", round(100*mean(diagnosedafter1yo == 0, na.rm = T),2), ")"),
              "No of individuals homozygous for F508 (%)" = paste0(sum(f508_homozygous == 1, na.rm = T),
                                                                " (", round(100*mean(f508_homozygous == 1, na.rm = T),2), ")"),
              "No of individuals with one FEV\u2081 measure (%)" = paste0(sum(no_encounters == 1),
                                                                       " (", round(100*mean(no_encounters == 1),2), ")"),
              "FEV\u2081 at first encounter (IQR)" = quantile_interval(first_fev),
              "FEV\u2081 at last encounter (IQR)" = quantile_interval(last_fev),
              "Number of deaths (%)" =paste0(sum(death_status == 1),
                                             " (", round(100*mean(death_status == 1),2), ")")
    )





tab1 <- tab1_prep %>%
  group_by(dmg_sex) %>%
  summarise("Number of individuals" = n_distinct(patient_id),
            "Median number of encounters per individual (IQR)" = quantile_interval(no_encounters),
                        "Difference in years between first and last encounter date (IQR)" = quantile_interval(ageatlastvisit - ageatfirstvisit),
            "Median age at diagnosis in years (IQR)" = quantile_interval(ageatdiagnosis),
            "No of individuals diagnosed within the first year after birth (%)" = paste0(sum(diagnosedafter1yo == 0, na.rm = T),
                                                                                  " (", round(100*mean(diagnosedafter1yo == 0, na.rm = T),2), ")"),
            "No of individuals homozygous for F508 (%)" = paste0(sum(f508_homozygous == 1, na.rm = T),
                                                                                  " (", round(100*mean(f508_homozygous == 1, na.rm = T),2), ")"),
            "No of individuals with one FEV\u2081 measure (%)" = paste0(sum(no_encounters == 1),
                                                                 " (", round(100*mean(no_encounters == 1),2), ")"),
            "FEV\u2081 at first encounter (IQR)" = quantile_interval(first_fev),
            "FEV\u2081 at last encounter (IQR)" = quantile_interval(last_fev),
            "Number of deaths (%)" =paste0(sum(death_status == 1),
                                           " (", round(100*mean(death_status == 1),2), ")")
  )




rbind(tab1, tab1_tot) %>%
  t() %>%
  kbl() %>%
  kable_paper("hover", html_font = "helvetica", full_width = F)
```

## MELSM analysis

Basic model (from [Hedeker et al., 2008](https://onlinelibrary.wiley.com/doi/full/10.1111/j.1541-0420.2007.00924.x)) : the submodel for the outcome mean includes as covariates age and sex with a random slope per subject; the submodel for the exponential of the standard deviation includes a random effect per subject. We also estimate the correlation between group-level effects.

-    $y_{ij} = x_{ij}^\mathsf{T}\beta + \upsilon_i + \varepsilon_{ij} \qquad \qquad i = 1,\dots N \text{ subjects, } j = 1,\dots, n_i \text{ visits}$

-   $\varepsilon_{ij}$ independent of $\upsilon_{i}, \; \forall i$

-   between-subject variance: $\upsilon_i \sim N(0, \sigma_{\upsilon_{i}}^2), \qquad \sigma_{\upsilon_{i}}^2 =\exp{(u_i^\mathsf{T}\alpha)}$

-   within-subjects variance: $\varepsilon_{ij} \sim N(0, \sigma_{\varepsilon_{ij}}^2), \qquad \sigma_{\varepsilon_{ij}}^2 = \exp{(w_{ij}^\mathsf{T}\tau + \omega_i)}$

-   random effects are correlated via $\rho$ $\begin{pmatrix}\upsilon_i\\\omega_{i}\end{pmatrix} \sim N \begin{bmatrix} \begin{pmatrix}0\\ 0\end{pmatrix}\!\!, \begin{pmatrix} \sigma_{\upsilon_{i}}^2 & \rho\sigma_{\upsilon_{i}}\sigma_{\omega_{i}} \\ & \sigma_{\omega_{i}}^2 \end{pmatrix} \end{bmatrix}$

For the complete model used in this analysis, see the Appendix of the paper.

By default, natural cubic regression spline (bs = 'cr') are defined by a modest sized set of knots spread evenly (by quantiles) through the covariate values. They are penalized by the conventional intergrated square second derivative cubic spline penalty (https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/smooth.terms.html). B-splines family (bs = 'bs', bs = 'ps', bs = 'ad') place knots evenly.


A list of the following objects:

- `bform`: it specifies the formula to be used in `brm`. Being a distributional model, we specify a model for the outcome `gli_fev` and one for the parameter `sigma`. The family of distributions is Gaussian.

- `prior_fitupdate`: it contains the prior specifications for the model.  

- `brms_fitprior`: it fits the model specified in `bform` with the prior specification in `prior_fitupdate` on the dataset `data_fit` with 2400 iterations (of which 1200 warm-up). First, only the prior is sampled (in case some prior checks are needed), than the model is updated in `brms_fit1`. Watanabe AIC and loo can be then added (useful for model comparison).

The factor-smooth interaction in `brms`, derived from the `mgcv` package, specifies a different smoothing function for each sex with a centering constraint with respect to the model intercept. Therefore, to account for sex mean differences, a main parametric term for sex is also included ( https://stat.ethz.ch/Rmanual/R-devel/library/mgcv/html/gam.models.html).

```{r model_fit, echo = TRUE, eval = FALSE}
###Note: this block takes a long time to run! Do not run unless you need to fit the model. You might also want to store the brms_fit1 model in a .rds file or a workspace.


seed1 <- 787878


bform <- bf(
  gli_fev ~ dmg_sex + s(age, by = dmg_sex, bs = 'cr', k = 5)  
  + diagnosedafter1yo 
  + s(yob, bs = 'cr', k = 5)
  + f508_homozygous 
  + (1 |ID| patient_id),  
  sigma ~ dmg_sex + s(age, by = dmg_sex, bs = 'cr', k = 5)
  + diagnosedafter1yo 
  + s(yob, bs = 'cr', k = 5)
  + f508_homozygous
  + (1 |ID| patient_id), 
  family = gaussian()
)




prior_fitupdate <- c(prior(normal(2, 0.01), class = Intercept),
                                   prior(normal(0, 0.01), class = b),
                                   prior(exponential(10), class = sd),
                                   
                                   prior(normal(0, 0.1), class = Intercept, dpar = sigma),
                                   prior(normal(0, 0.1), class = b, dpar = sigma),
                                   prior(exponential(10), class = sd, dpar = sigma),
                                   
                                   prior(exponential(10), class = sds),
                                   prior(exponential(10), class = sds, dpar = sigma),
                                   prior(lkj(2), class = cor))




brms_fitprior <- brm(bform,
                       data = data_fit,
                       seed = seed1,
                       prior = prior_fitupdate,    
                       warmup = 1200,
                       iter = 2400,
                       thin = 5,
                       chains = 2, cores = 2
                       , sample_prior = "only"
                       , control = list(adapt_delta = 0.95)
                     )


fit1_time <- system.time(
  brms_fit1 <-  update(brms_fitprior, sample_prior="no", cores = 2, seed = seed1)
)    

brms_fit1 <- add_criterion(brms_fit1, c("waic", "loo"), cores = 2)

```


## Model summary

The package `brms` uses only complete cases, that is, the subjects with no NAs in the covariates selected for the model.

```{r modelWS, fig.dim=c(5,4), echo = FALSE, eval = TRUE}
load("melsm_epinet_adultfev_13799262.RData") 
```


```{r modelsummary, fig.dim=c(5,4), echo = TRUE, eval = TRUE}
summary(brms_fit1)   
```

### Fitted values for individuals within the dataset

To derive fitted values, a reference guide is in https://www.andrewheiss.com/blog/2022/09/26/guide-visualizing-types-posteriors/#tldr-diagrams-and-cheat-sheets and https://www.andrewheiss.com/blog/2021/11/10/ame-bayes-re-guide/. In particular, if you use `re_formula = NULL` in the `fitted` command, you are including the random effects, while if you use `re_formula = NA` you are only getting the grand mean (given the covariates). The smooth means of the fitted values with `re_formula = NULL` and the smooth means of the fitted values with `re_formula = NA` are exactly the same because the mean of random effects is equal to zero.


```{r fittedvalues, echo = TRUE, eval = TRUE}

fitted_mu <- fitted(brms_fit1, re_formula = NULL, scale  = "response", dpar = "mu") %>%
  as.data.frame()
colnames(fitted_mu) <- paste0("mu_", colnames(fitted_mu))
fitted_sigma <- fitted(brms_fit1, re_formula = NULL, scale  = "response", dpar = "sigma") %>%
  as.data.frame()
colnames(fitted_sigma) <- paste0("sigma_", colnames(fitted_sigma))


explanatory_after <- c("patient_id", "age", "dmg_sex", "diagnosedafter1yo", "dmg_dateofbirth", "f508_homozygous")
dependent <-  "gli_fev"


fittedpars_withcovariates <- data_fit %>% 
  select(all_of(c(explanatory_after, dependent, "dmg_deathhaspatientdied", "Transplanted"))) %>% 
  drop_na() %>% 
  cbind(., fitted_mu, fitted_sigma)

fittedpars_withcovariates_reshaped <- fittedpars_withcovariates  %>%
  gather(dpar, Estimate, c("mu_Estimate", "sigma_Estimate")) %>%
  mutate(ymin = ifelse(dpar == "sigma_Estimate", 0, 0.95),
         ymax = ifelse(dpar == "sigma_Estimate", 0.7, 3.5)) %>%###ymin to make sure that y-axis in sigma subplots includes 0
  select(-ends_with(c("Est.Error", "Q2.5", "Q97.5")))


###Plots
fittedpars_withcovariates_reshaped %>%
  filter(patient_id %in% sample(fittedpars_withcovariates_reshaped$patient_id, 300)
         & dpar == "sigma_Estimate") %>%
  ggplot(aes(x = age, y = Estimate, group = patient_id, color = diagnosedafter1yo)) +
  geom_line(alpha = 0.2) +
  facet_grid( ~ dmg_sex, scales = "free") + 
  geom_smooth(data = filter(fittedpars_withcovariates_reshaped, dpar == "sigma_Estimate"), 
              aes(x = age, y = Estimate, group = diagnosedafter1yo, color = diagnosedafter1yo),
              linewidth = 1.25) +  
  scale_color_manual(values = c("#5F4B8BFF", "#E69A8DFF"))


fittedpars_withcovariates_reshaped$dpar <- factor(fittedpars_withcovariates_reshaped$dpar,
        labels = c(~ list("FEV"[1]~"mean"), ~ list("FEV"[1]~"SD")))

fittedpars_withcovariates_reshaped$dmg_sex <- factor(fittedpars_withcovariates_reshaped$dmg_sex,
        labels = c(~ list("Females"), ~ list("Males")))



fittedpars_withcovariates_reshaped %>%
  ggplot(aes(x = age, y = Estimate)) +
  facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) +
  geom_smooth(aes(x = age, y = Estimate, 
                  group = dmg_deathhaspatientdied, 
                  color = dmg_deathhaspatientdied,
                  fill = dmg_deathhaspatientdied), 
              size = 0, lty = 0, alpha = 0) +
  geom_smooth(size = 1, col = 1, lty = 1) +
  scale_color_manual(values = c( "#E69A8DFF","#5F4B8BFF"), labels = c("", "")) +
  scale_fill_manual(values = c("#E69A8DFF", "#5F4B8BFF"), labels = c("", "")) +
  geom_blank(aes(y = ymin)) + geom_blank(aes(y = ymax)) +
  labs(x = "Age", y = "Average trajectory", fill = "", color = "", title = "")

fittedpars_withcovariates_reshaped %>%
  ggplot(aes(x = age, y = Estimate, 
             group = dmg_deathhaspatientdied, 
             color = dmg_deathhaspatientdied, 
             fill = dmg_deathhaspatientdied,
             lty = dmg_deathhaspatientdied)) +
  facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) + 
  geom_smooth(size = 1) +  
  scale_color_manual(values = c("#445C40", "#E69A8DFF"), labels = c("No", "Yes")) +
  scale_fill_manual(values = c("#445C40", "#E69A8DFF"), labels = c("No", "Yes")) + 
  scale_linetype_manual(values = c("11", "81"), labels = c("No", "Yes")) + 
  geom_blank(aes(y = ymin)) + geom_blank(aes(y = ymax)) +
  xlim(18, 50) +
  labs(x = "Age", y = "Average trajectory", fill = "Died during follow-up", color = "Died during follow-up", lty = "Died during follow-up", title = "")
```



```{r fittedvalues_other, echo = FALSE, eval = FALSE}
fittedpars_withcovariates_reshaped %>%
  ggplot(aes(x = age, y = Estimate)) +
  facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) +
  geom_smooth(size = 1.5, col = 1, lty = 1, alpha = 0.8) +
  geom_smooth(aes(x = age, y = Estimate,
                  group = dmg_deathhaspatientdied,
                  color = dmg_deathhaspatientdied,
                  fill = dmg_deathhaspatientdied),
              size = 1, lty = "81", alpha = 0.2) +
  scale_color_manual(values = c( "#D4AF37","#5F4B8BFF"), labels = c("No", "Yes")) +
  scale_fill_manual(values = c("#D4AF37", "#5F4B8BFF"), labels = c("No", "Yes")) +
  geom_blank(aes(y = ymin)) + geom_blank(aes(y = ymax)) +
  labs(y = "Average prediction", fill = "Dead", color = "Dead")


fittedpars_withcovariates_reshaped %>%
  ggplot(aes(x = age, y = Estimate, 
             group = diagnosedafter1yo, 
             color = diagnosedafter1yo)) +
  facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) + 
  geom_smooth(size = 1.25) +  
  scale_color_manual(values = c("#5F4B8BFF", "#E69A8DFF")) + 
  geom_blank(aes(y = ymin)) + 
  geom_blank(aes(y = ymax))


fittedpars_withcovariates_reshaped %>%
  ggplot(aes(x = age,
             y = Estimate, 
             group = f508_homozygous, 
             color = f508_homozygous, 
             fill = f508_homozygous)) +
  facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) + 
  geom_smooth(size = 1) +  
  scale_color_manual(values = c("#5F4B8BFF", "#E69A8DFF")) +
  scale_fill_manual(values = c("#5F4B8BFF", "#E69A8DFF")) + 
  geom_blank(aes(y = ymin)) + 
  geom_blank(aes(y = ymax))




fittedpars_withcovariates_reshaped  %>% 
  dplyr::mutate(homoz_diagafter1 = interaction(f508_homozygous, diagnosedafter1yo, sep = ":")) %>%
  ggplot(aes(x = age, 
             y = Estimate, 
             group = homoz_diagafter1, 
             color = homoz_diagafter1, 
             fill = homoz_diagafter1)) +
  facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) + 
  geom_smooth(size = 1) +  
  scale_color_manual(values = c("#A37B73FF", "#3E282B", "#D4AF37", "#D34F73FF")) + 
  scale_fill_manual(values =  c("#A37B73FF", "#3E282B", "#D4AF37", "#D34F73FF")) + 
  geom_blank(aes(y = ymin)) + 
  geom_blank(aes(y = ymax))

```


### Predicted values for specific covariate values

As in the previous section, if you specify `re_formula = NA` you do not include any ID (you are getting predictions for an average individual). If you need conditional effects for existing individuals, then use `re_formula = NULL` or equivalently `re_formula = ~ (1 | patient_id))`. If you want a new hypothetical individual, you can use `patient_id = NA, allow_new_levels = TRUE, re_formula = ~ (1 | patient_ID)` and then you specify `sample_new_levels` either equal to "uncertainty" or "gaussian" in the prediction function.

```{r predict_brms, echo = TRUE, eval = TRUE}
yob_levels <- c(1963, 1984, 1993)


epred_byage <- brms_fit1 %>% 
  epred_draws(newdata = expand.grid(dmg_sex = c("F", "M"),
                      age = seq(18,50,by=2),
                      diagnosedafter1yo = c(0,1),
                      yob = yob_levels,
                      f508_homozygous = c(0,1), patient_id = "B155916"),  
              re_formula = NA, dpar = TRUE)


epred_byage_reshaped <- epred_byage  %>%
  gather(dpar, Estimate, c("mu", "sigma")) %>%
    mutate(ymin = ifelse(dpar == "sigma", 0, 1.05),
         ymax = ifelse(dpar == "sigma", 1, 2.75)) ###ymin to make sure that y-axis in sigma subplots includes 0

epred_byage_reshaped$dpar <- factor(epred_byage_reshaped$dpar,
        labels = c(~ list("FEV"[1]~"mean"), ~ list("FEV"[1]~"SD")))

epred_byage_reshaped$dmg_sex <- factor(epred_byage_reshaped$dmg_sex,
        labels = c(~ list("Females"), ~ list("Males")))





epred_byage_reshaped %>% filter(diagnosedafter1yo == 0, f508_homozygous == 1) %>%
  ggplot(aes(x = age, y = Estimate, 
             color = rev(factor(yob)), 
             fill = rev(factor(yob)),
             lty = rev(factor(yob)))) +
  facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0, colour = NA) + ###to get same y-axis across plots
  stat_lineribbon(.width = 0.95, alpha = 1/4, show.legend = TRUE) +
  scale_color_manual(values = c( "#445C40","#3E282B","#EF9806"), 
                     labels = rev(yob_levels), 
                     guide = guide_legend(reverse = TRUE)) +
  scale_fill_manual(values = c("#445C40","#3E282B","#EF9806"), 
                    labels = rev(yob_levels),
                    guide = guide_legend(reverse = TRUE)) +
  scale_linetype_manual(values = c("11", "81", "solid"), 
                        labels = rev(yob_levels),
                        guide = guide_legend(reverse = TRUE)) +
  labs(x = "Age", y = "Prediction", linetype = "Year of birth", 
       fill = "Year of birth", color = "Year of birth", 
       title = "Homozygous F508, diagnosed before 1 year old") +
  theme(plot.title=element_text(size=12))



epred_byage_reshaped %>% filter(diagnosedafter1yo == 0, yob == yob_levels[2]) %>%
    ggplot(aes(x = age, y = Estimate, 
               color = factor(f508_homozygous), 
               fill = factor(f508_homozygous), 
               lty = factor(f508_homozygous)))  +
    facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) + 
    geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0, colour = NA) +
    stat_lineribbon(.width = 0.95, alpha = 1/3, show.legend = TRUE) +
    scale_color_manual(values = c("#3E282B","#EF9806"), labels = c("No", "Yes")) +
    scale_fill_manual(values = c("#3E282B","#EF9806"), labels = c("No", "Yes")) + 
    scale_linetype_manual(values = c("11", "81"), labels = c("No", "Yes")) + 
    labs(x = "Age", y = "Prediction", linetype = "Homozygous F508", 
         fill = "Homozygous F508", color = "Homozygous F508", 
         title = paste0("Born in ", yob_levels[2], ", diagnosed before 1 year old")) +
    theme(plot.title=element_text(size=12))



epred_byage_reshaped %>% filter(f508_homozygous == 1, yob == yob_levels[2]) %>%
    ggplot(aes(x = age, y = Estimate, 
               color = factor(diagnosedafter1yo), 
               fill = factor(diagnosedafter1yo), 
               lty = factor(diagnosedafter1yo)))  +
    facet_grid(dpar ~ dmg_sex, scales = "free",  labeller = label_parsed) + 
    geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0, colour = NA) +
    stat_lineribbon(.width = 0.95, alpha = 1/3, show.legend = TRUE) +
    scale_color_manual(values = c("#3E282B","#EF9806"), labels = c("No", "Yes")) +
    scale_fill_manual(values = c("#3E282B","#EF9806"), labels = c("No", "Yes")) + 
    scale_linetype_manual(values = c("11", "81"), labels = c("No", "Yes")) + 
    labs(x = "Age", y = "Prediction", linetype = "Diagnosed after 1 year old", 
         fill = "Diagnosed after 1 year old", color = "Diagnosed after 1 year old", 
         title = paste0("Born in ", yob_levels[2], ", homozygous F508")) +
    theme(plot.title=element_text(size=12))

```


## Estimated coefficients

```{r param_data}
cond_smooth_data <- lapply(conditional_smooths(brms_fit1, method = "fitted"), as.data.frame) %>% 
  bind_rows(.id = "coef_function") %>%
  mutate(submodel = factor(str_extract(coef_function, "[^: ]+"), 
                                                labels = c("Location submodel", "Scale submodel")),
                  xvar = factor(sapply(str_extract_all(coef_function, "[^(*),]+"), "[[",2)),
                  byvar = str_match(coef_function, "by=\\s*(.*?)\\s*,")[,2]
  ) 
```

```{r param_agebysex_withsexmaineffect}

sexmaineffect <- summary(brms_fit1)$fixed[c("dmg_sexM", "sigma_dmg_sexM"),1]

cond_smooth_data_WITHINTERACTION <- cond_smooth_data %>%
  mutate_at(
    vars("estimate__", "lower__","upper__"),
    funs(case_when(dmg_sex == "M" & submodel == "Location submodel" ~ . + sexmaineffect[1],
                   dmg_sex == "M" & submodel == "Scale submodel" ~ .  + sexmaineffect[2],
                   TRUE ~ .)) 
  )



cond_smooth_data_WITHINTERACTION %>%
  ggplot(., aes(x = effect1__, fill = dmg_sex)) + 
    geom_line(aes(y = estimate__,  color = dmg_sex, linetype = dmg_sex)) + 
  facet_grid(submodel ~ xvar, scales = "free", switch = 'y',
             labeller = labeller(
               xvar = c(`age` = "Age", `yob` = "Year of birth"),
               submodel = c(`Location submodel` = "Mean trajectory", 
                            `Scale submodel` = "Variability (log SD)")
             )) + 
  geom_ribbon(aes(ymin = lower__, ymax = upper__), alpha = 0.3, colour = NA) +
  labs(x = "", y = bquote("Additive effect on FEV"[1]), 
       fill = "Sex", color = "Sex", linetype = "Sex") + 
  theme(plot.margin = margin(t = 2, r = 10, b = 2, l = 2, unit = "pt"),
        legend.position="bottom", 
        legend.margin=margin(0,0,0,0,unit = "pt"), 
        legend.box.margin=margin(0,0,0,0,unit = "pt"),
        panel.grid.minor = element_line(),
        panel.spacing.y = unit(0.5, "lines"),
        axis.text=element_text(size=10)) +  
  scale_color_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) + 
  scale_fill_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) +
  scale_linetype_manual(breaks = c("F", "M"), values = c("81", "11"), 
                        na.value = "solid") 
```

## Random effects

Let us look first at the standard deviation of the scale random effect. The probability that this parameter is higher than zero is very close to 1.

```{r hypothesis, fig.dim=c(5,3)}
hyp <- c("sd_patient_id__sigma_Intercept^2 = 0")
hypothesis(brms_fit1, hyp, class = NULL)

mcmc_dens(brms_fit1, pars = "sd_patient_id__sigma_Intercept")  + 
    labs(x = expression(sigma[omega]))
```

Bonus point: a subject specific random intercept is a category smoother (check https://www.tjmahr.com/random-effects-penalized-splines-same-thing/ to understand the equivalence between splines and random effects).

Now we create the dataset `ranef_df` joining demographic information and random effects.


```{r ranef, fig.dim=c(5,3)}
visitcount <- data_fit %>% 
  group_by(patient_id) %>%
  summarise(dmg_sex,
           "no_visits" = n(),
            "ageatfirstvisit" = first(age),
            "ageatdiagnosis" = first(dmg_ageatdiagnosis), 
            "death_status" = !is.na(dmg_dateofdeath)
          ) %>% 
  distinct(across(everything())) 



ranef_df0 <- ranef(brms_fit1, groups="patient_id", probs = c(0.025, 0.975)) %>%
  data.frame()
names(ranef_df0) <- str_remove(names(ranef_df0), "patient_id.")


ranef_df <- tibble::rownames_to_column(ranef_df0, var = "patient_id") %>%
  left_join(., visitcount, by =  "patient_id") 

repeated_id <- ranef_df %>% 
  count(patient_id) %>% 
  filter(n>1) %>% 
  pull(patient_id) ##appear twice in ranef_df ###recorded as both males and females

ranef_df <- filter(ranef_df, patient_id  %ni% repeated_id)

ranef_df <- ranef_df %>% 
  mutate(sub_muintercept = Estimate.Intercept +
           summary(brms_fit1)$fixed["Intercept",1],
         sub_sigmaintercept = exp(Estimate.sigma_Intercept +
                                    summary(brms_fit1)$fixed["sigma_Intercept",1])
         )



```


```{r ranef_plots, fig.dim=c(5,3)}
ggplot(data = ranef_df[1:500,],
              aes(x = Estimate.Intercept, y = Estimate.sigma_Intercept)) +
  geom_linerange(aes(xmin = Q2.5.Intercept, xmax = Q97.5.Intercept), alpha = 0.1) +
  geom_linerange(aes(ymin = Q2.5.sigma_Intercept, ymax = Q97.5.sigma_Intercept), alpha = 0.1) +
  geom_point(aes(color = dmg_sex), alpha = 0.4, size = 0.9) + 
  geom_smooth(data = ranef_df,
                            aes(x = Estimate.Intercept, y = Estimate.sigma_Intercept),
                            method = "lm", se = TRUE, col = 1
              ) + 
  geom_smooth(data = ranef_df, 
                            aes(x = Estimate.Intercept, y = Estimate.sigma_Intercept, 
                                color = dmg_sex, fill = dmg_sex, linetype = dmg_sex),
              method="gam", formula = y ~ s(x, bs = "cs", k=5),
              size = 1.25
              ) +
  scale_color_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) +
  scale_fill_manual(breaks = c("F", "M"), values = c("#F8766D", "#001D81")) + 
  scale_linetype_manual(breaks = c("F", "M"), values = c("longdash", "solid"), 
                        na.value = "solid") +
  labs(x = "Location random effects", y = "Scale random effects", color = "Sex", fill = "Sex",
         linetype = "Sex") +
  theme(panel.grid.major = element_blank())
```


```{r ranef_bysamplesize, fig.dim=c(5,5)}
ggplot(data = ranef_df,
       aes(x = Estimate.sigma_Intercept, 
           y = factor(no_visits),  
           fill = stat(x))
       ) +
  geom_density_ridges_gradient(alpha=0.6,rel_min_height = 0.01) +
  theme_ridges() + 
  labs(x = "Scale random effect", y = "Number of encounters") + 
  scale_fill_viridis_c(option = "C") +
  theme(legend.position = "none")
```



## Posterior checks

If you want to check autocorrelation of the MCMC samples, you can run the following code.
```{r mcmc_acf, out.width = "99%", eval = FALSE}
mcmc_plot(brms_fit1, type = "acf") + 
    theme(strip.text.x = element_text(size = 14, angle = 90)) ###you would like to see L-shaped plots

```

The model fit took approximately `r round(fit1_time[3]/3600, 2)` hours.

Posterior predictive distribution:

$$p(\tilde{y}| y ) = \int p(\tilde{y}|\theta)p(\theta|y)d\theta$$


```{r pp_check, echo  = TRUE, eval = TRUE, fig.dim=c(5,3)}
pp_check(brms_fit1) + theme(legend.position = "bottom") ##density overlay
pp_check(brms_fit1, type = "ecdf_overlay")
```

For multiple models, model comparison is performed in terms of best predictive ability, via either Bayesian LOO-CV and Watanabe AIC (WAIC, asymptotically equivalent to LOO-CV). The best model is the one with lower LOO-CV. Larger ELPD values indicate better fit.


## Session info

```{r sessioninfo}
sessionInfo()
```

